{"id": "on-matrix-inversion-in-python", "title": "On Matrix Inversion in Python", "content": "In the introductory programming course that I lecture, the big programming project that I set for the students involved writing a number of matrix operations in pure Python (that is, using built-in functions only - I specifically disallowed the use of any imported modules like NumPy). Transposition and matrix multiplication are fairly simple to do, but the challenge is in writing a function to invert a matrix. <div class=\"readmore\"> <br/><br/>Of course, Gauss-Jordan elimination (which should be covered in any first year algebra course) is one of the easier ways to do this. I wrote a fairly long but simple-to-understand function to give out to the students as a model solution at the end of the project, but I was wondering, how short could a working matrix inversion function be?<br/><br/>I came up with the function below, complete with partial pivoting, which seems to work correctly. It could probably be even shorter, but I think I achieved what I set out to do:<br/><br/>\n<app-gist-container id=\"gist-36291e29b63c8b6905bb\" src=\"https://gist.github.com/AlphaSheep/36291e29b63c8b6905bb.js\"></app-gist-container>\n<br/>The input argument A is simply a nested list, such as <br/><span style=\"font-family: Courier New, Courier, monospace;\">\u00a0\u00a0\u00a0\u00a0A = [[1,2,3],[1,5,9],[7,5,2]]</span><br/><br/>Line 3 simply augments the matrix with the identity matrix. The for loop on line 4 loops through each row, and sets the element on the main diagonal to 1, and every element above and below that element to zero. This happens in three steps. The first step, on line 5, is a simple pivoting step. It sorts all of the remaining rows such that the current row will be divided by the number with the largest possible magnitude (to avoid division by zero, and improve the accuracy if the matrix contains very small numbers). The second step (line 6) is to divide each element in the row by the element on the main diagonal, leaving a 1 on the main diagonal. The third step (line 7) is a little more complicated. For each row that is not the current row, we subtract the current row multiplied by the element in the column index equal to the index of the current row. This will set each element in the current column to zero, except for the element in the current row, which remains 1.<br/><br/>The net result is that the left hand side of the augmented matrix becomes the identity matrix, while the right hand side becomes the inverse. All that's left is to separate the two, and return the inverse. This happens on line 8.<br/><br/>I don't know who would find this post useful, because it's better to just use numpy, but it is certainly a fun exercise.<br/><br/></div>", "published": "2015-06-03T12:09:00+02:00", "updated": "2015-06-03T12:09:06.504000+02:00", "draft": false, "categories": ["programming", "mathematics"]}